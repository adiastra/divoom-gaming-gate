<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
  <style>
    body, html {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: transparent;
    }
    #c {
      border: 1px solid #444;
      background: #222;
    }
  </style>
</head>
<body>
  <canvas id="c" width="512" height="512"></canvas>
  <script>
    const canvas = new fabric.Canvas('c', {
      backgroundColor: '#222',
      selection: true
    });
    canvas.setZoom(4);

    const frames = [];
    let current = 0;
    let playInt = null;
    let loading = false;

    function saveCur() {
      if (!loading) {
        frames[current] = canvas.toJSON();
      }
    }

    function load(idx) {
      if (idx < 0 || idx >= frames.length) return;
      loading = true;
      canvas.clear();
      canvas.loadFromJSON(frames[idx], () => {
        canvas.renderAll();
        current = idx;
        loading = false;
      });
      return `${current + 1}/${frames.length}`;
    }

    frames.push(canvas.toJSON());

    window.EditorAPI = {
      newRect() {
        canvas.add(new fabric.Rect({
          left: 50,
          top: 50,
          width: 100,
          height: 100,
          fill: 'transparent',
          stroke: 'white',
          strokeWidth: 2,
          cornerColor: 'cyan',
          cornerSize: 8
        })).setActiveObject(canvas.item(canvas.size() - 1));
      },
      newCircle() {
        canvas.add(new fabric.Circle({
          left: 60,
          top: 60,
          radius: 50,
          fill: 'transparent',
          stroke: 'white',
          strokeWidth: 2,
          cornerColor: 'cyan',
          cornerSize: 8
        })).setActiveObject(canvas.item(canvas.size() - 1));
      },
      newPolygon() {
        // Regular hexagon as default
        const sides = 6;
        const radius = 50;
        const centerX = 100;
        const centerY = 100;
        const points = [];
        for (let i = 0; i < sides; i++) {
          const angle = (2 * Math.PI * i) / sides;
          points.push({
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
          });
        }
        canvas.add(new fabric.Polygon(points, {
          fill: 'transparent',
          stroke: 'white',
          strokeWidth: 2,
          cornerColor: 'cyan',
          cornerSize: 8
        })).setActiveObject(canvas.item(canvas.size() - 1));
      },
      newText(t) {
        canvas.add(new fabric.Text(t, {
          left: 60,
          top: 60,
          fill: 'white',
          fontSize: 24,
          cornerColor: 'cyan',
          cornerSize: 8
        })).setActiveObject(canvas.item(canvas.size() - 1));
      },
      clear() {
        canvas.clear();
        canvas.setBackgroundColor('#222');
      },
      exportFrame() {
        return canvas.toDataURL({ format: 'png' });
      },
      exportAllFrames() {
        saveCur();
        return frames.map(js => {
          const sc = new fabric.StaticCanvas(null, {
            width: 512,
            height: 512,
            backgroundColor: '#222'
          });
          sc.setZoom(4);
          sc.loadFromJSON(js, sc.renderAll.bind(sc));
          return sc.toDataURL({ format: 'png' });
        });
      },
      addFrame() {
        saveCur();
        canvas.clear();
        canvas.setBackgroundColor('#222');
        frames.push(canvas.toJSON());
        current = frames.length - 1;
        return `${current + 1}/${frames.length}`;
      },
      cloneFrame() {
        saveCur();
        frames.splice(current + 1, 0, JSON.parse(JSON.stringify(frames[current])));
        return load(current + 1);
      },
      prevFrame() {
        saveCur();
        if (current > 0) return load(current - 1);
        return `${current + 1}/${frames.length}`;
      },
      nextFrame() {
        saveCur();
        if (current < frames.length - 1) return load(current + 1);
        return `${current + 1}/${frames.length}`;
      },
      playAnimation(ms) {
        if (playInt) clearInterval(playInt);
        playInt = setInterval(() => {
          this.nextFrame();
          if (current === frames.length - 1) {
            saveCur();
            load(0);
          }
        }, ms);
      },
      stopAnimation() {
        if (playInt) clearInterval(playInt);
        playInt = null;
      }
    };

    [
      'object:modified',
      'object:added',
      'object:removed',
      'text:changed'
    ].forEach(ev => canvas.on(ev, saveCur));
  </script>
</body>
</html>
